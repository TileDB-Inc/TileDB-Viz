import { BoundingInfo, Camera, Vector3 } from '@babylonjs/core';
import { TileContent } from './tileContent';
import { RefineStrategy, TilingScheme } from '../../types';

export enum TileState {
  HIDDEN = 0b0,

  /**
   * The tile request has been scheduled but not dispatched yet.
   */
  PENDING_LOAD = 0b1,

  /**
   * The tile request has been dispatched.
   */
  LOADING = 0b10,

  /**
   * Tile has loaded and is currently being rendered.
   */
  VISIBLE = 0b100,

  /**
   * Tile has been marked for delete during the next cleanup step.
   */
  PENDING_DELETE = 0b1000
}

export class Tile<T, C extends TileContent = TileContent> {
  /**
   * Global tile counter used as unique id for tiles.
   */
  private static tileCount = 0;

  /**
   * Unique autogenerated tile id.
   */
  public readonly id: number = Tile.tileCount++;

  /**
   * Unique tile identifier inside the dataset. For datasets with morton indexes
   * this array contains only a single value, the morton index.
   */
  public index: number[];

  /**
   * The bounding info in the projected coordinate system.
   */
  public boundingInfo: BoundingInfo;

  /**
   * The tiles refinement strategy.
   */
  public refineStrategy: RefineStrategy;

  /**
   * The geometric error in the projected coordinate system.
   */
  public geometricError: number;

  /**
   * The child tiles of the tile. In case of implicit tiles more child tiles may be added during runtime.
   */
  public children: Array<Tile<T, C>>;

  /**
   * The parents of the tile or empty if the tile is the tileset root.
   */
  public parents: Tile<T, C>[];

  /**
   * The tile content.
   */
  public content: Array<T>;

  /**
   * The tiles tiling scheme. If value is `TilingScheme.NONE` indication of explicit tileset.
   * Default value is `TilingScheme.NONE`.
   */
  public tilingScheme: TilingScheme;

  /**
   * The tile state the provides info regarding the loading and visibility state of the tile.
   */
  public state: TileState;

  /**
   *
   */
  public mask: number;

  /**
   * The tiles renderable data object used for updating the data state
   */
  public data?: C;

  constructor() {
    this.boundingInfo = new BoundingInfo(
      Vector3.ZeroReadOnly,
      Vector3.ZeroReadOnly
    );
    this.refineStrategy = RefineStrategy.ADD;
    this.children = [];
    this.content = [];
    this.index = [];
    this.parents = [];
    this.tilingScheme = TilingScheme.NONE;
    this.geometricError = 0;
    this.state = TileState.HIDDEN;
    this.mask = 0;
  }

  public dispose() {
    this.data?.dispose();
    this.data = undefined;
  }

  /**
   * @see https://stackoverflow.com/questions/1104939/calculating-screen-space-error
   */
  public screenSpaceError(camera: Camera): number {
    if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
      return (
        this.geometricError /
        (Math.max(
          camera.orthoTop! - camera.orthoBottom!,
          camera.orthoRight! - camera.orthoLeft!
        ) /
          Math.max(
            camera.getEngine().getRenderHeight(),
            camera.getEngine().getRenderWidth()
          ))
      );
    } else {
      const height = camera.getScene().getEngine().getRenderHeight() / 2;
      const slope = Math.tan(camera.fov / 2);

      return (
        (this.geometricError * height) /
        (slope *
          Math.max(
            camera.position
              .subtract(this.boundingInfo.boundingSphere.centerWorld)
              .length(),
            Number.EPSILON
          ))
      );
    }
  }
}
